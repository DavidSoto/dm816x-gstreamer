This patch is a workaround for the capture driver bugs found during porting
v4l2src element on TI Davinci platforms (DM6446, DM355 and DM6467). The patch
is tested on LSP 1.2, LSP 1.3 and LSP 2.00.00.90.

DM6467
------
* Add YUV422UVP pixelformat support.

DM355/DM6446/DM6467
--------------------
- Driver returns EINVAL while probing maximum supported resolution. 
  The workaround is to set resolution by parsing video std.
- Driver does not return correct framerate while enumerating video standard.
  The workaround is to use the hard-coded fps.
- Driver does not return correct number of bytesused in VIDIOC_DQBUF ioctl.

diff -c -r orig/gst-plugins-good-0.10.15/sys/v4l2/gstv4l2src.c gst-plugins-good-0.10.15/sys/v4l2/gstv4l2src.c
*** orig/gst-plugins-good-0.10.15/sys/v4l2/gstv4l2src.c	2009-05-11 19:00:07.000000000 -0500
--- gst-plugins-good-0.10.15/sys/v4l2/gstv4l2src.c	2009-06-11 18:12:34.000000000 -0500
***************
*** 132,137 ****
--- 132,140 ----
  #ifdef V4L2_PIX_FMT_YVYU
    V4L2_PIX_FMT_YVYU,
  #endif
+ #ifdef V4L2_PIX_FMT_YUV422UVP
+   V4L2_PIX_FMT_YUV422UVP
+ #endif
  };
  
  #define GST_V4L2_FORMAT_COUNT (G_N_ELEMENTS (gst_v4l2_formats))
***************
*** 780,785 ****
--- 783,796 ----
        structure = gst_structure_new ("video/x-pwc2", NULL);
        break;
  #endif
+ #ifdef V4L2_PIX_FMT_YUV422UVP
+     case V4L2_PIX_FMT_YUV422UVP: {
+       guint32 fcc = GST_MAKE_FOURCC ('Y', '8', 'C', '8');
+       structure = gst_structure_new ("video/x-raw-yuv",
+         "format", GST_TYPE_FOURCC, fcc, NULL);
+       break;
+     }
+ #endif
      default:
        GST_DEBUG ("Unknown fourcc 0x%08x %" GST_FOURCC_FORMAT,
            fourcc, GST_FOURCC_ARGS (fourcc));
***************
*** 992,997 ****
--- 1003,1013 ----
          outsize = (GST_ROUND_UP_2 (*w) * 2) * *h;
          break;
  #endif
+ #ifdef V4L2_PIX_FMT_YUV422UVP
+       case GST_MAKE_FOURCC ('Y', '8', 'C', '8'):
+         fourcc = V4L2_PIX_FMT_YUV422UVP;
+         break;
+ #endif
      }
    } else if (!strcmp (mimetype, "video/x-raw-rgb")) {
      gint depth, endianness, r_mask;
***************
*** 1103,1109 ****
--- 1119,1127 ----
      return FALSE;
  
    /* now store the expected output size */
+   #if defined(DAVINCI_LSP_WORKAROUND) && !defined(Platform_dm6467)
    v4l2src->frame_byte_size = size;
+   #endif
  
    return TRUE;
  }
diff -c -r orig/gst-plugins-good-0.10.15/sys/v4l2/v4l2src_calls.c gst-plugins-good-0.10.15/sys/v4l2/v4l2src_calls.c
*** orig/gst-plugins-good-0.10.15/sys/v4l2/v4l2src_calls.c	2009-05-11 19:00:07.000000000 -0500
--- gst-plugins-good-0.10.15/sys/v4l2/v4l2src_calls.c	2009-06-11 18:04:15.000000000 -0500
***************
*** 564,569 ****
--- 564,681 ----
    }
  }
  
+ #if defined(DAVINCI_LSP_WORKAROUND)
+ /******************************************************
+  * gst_v4l2src_get_resolution
+  *   get the video resolution
+  *****************************************************/
+ static void  gst_v4l2src_get_resolution (GstV4l2Src *v4l2src, gint *width,
+         gint *height, gint *fps_num, gint *fps_denom)
+ {
+   gint fd = v4l2src->v4l2object->video_fd;
+   gint failCount = 0, ret;
+   v4l2_std_id  std;
+ 
+   /* It might take a few tries to detect the signal */
+   do {
+     ret = ioctl(fd, VIDIOC_QUERYSTD, &std);
+     if (ret == -1 && errno == EAGAIN) {
+         usleep(1);
+         failCount++;
+     }
+   }while(ret == -1 && errno == EAGAIN && failCount < 5);
+ 
+   if (ret == -1) {
+     GST_ERROR("failed to query standard, Video input connected ?\n");
+   }
+ 
+   if (std & V4L2_STD_NTSC) {
+     GST_LOG("found ntsc standard\n");
+     *width = 720;
+     *height = 480;
+     *fps_num = 30000;
+     *fps_denom = 1001;
+   }
+   else if (std & V4L2_STD_PAL) {
+     GST_LOG("found pal standard\n");
+     *width = 720;
+     *height = 576;
+     *fps_num = 25;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_525P_60) {
+     GST_LOG("found 525p standard\n");
+     *width = 720;
+     *height = 480;
+     *fps_num = 30000;
+     *fps_denom = 1001;
+   }
+   else if (std & V4L2_STD_625P_50) {
+     GST_LOG("found 625p standard\n");
+     *width = 720;
+     *height = 576;
+     *fps_num = 25;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_720P_60) {
+     GST_LOG("found 720p @60fps standard\n");
+     *width = 1280;
+     *height = 720;
+     *fps_num = 60;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_720P_50) {
+     GST_LOG("found 720p @50fps standard\n");
+     *width = 1280;
+     *height = 720;
+     *fps_num = 50;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_1080I_60) {
+     GST_LOG("found 1080i @60fps standard\n");
+     *width = 1920;
+     *height = 1080;
+     *fps_num = 60;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_1080I_50) {
+     GST_LOG("found 1080i @50fps standard\n");
+     *width = 1920;
+     *height = 1080;
+     *fps_num = 50;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_1080P_30) {
+     GST_LOG("found 1080p @30fps standard\n");
+     *width = 1920;
+     *height = 1080;
+     *fps_num = 30;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_1080P_25) {
+     GST_LOG("found 1080p @25fps standard\n");
+     *width = 1920;
+     *height = 1080;
+     *fps_num = 25;
+     *fps_denom = 1;
+   }
+   else if (std & V4L2_STD_1080P_24) {
+     GST_LOG("found 1080p @24fps standard\n");
+     *width = 1920;
+     *height = 1080;
+     *fps_num = 24;
+     *fps_denom = 1;
+   }
+   else {
+     GST_WARNING("failed to detect video standard\n");
+     *width = 1;
+     *height = 1;
+     *fps_num = 1;
+     *fps_denom = 1;
+   }
+ }
+ #endif
+ 
  /******************************************************
   * gst_v4l2src_clear_format_list():
   *   free list of supported capture formats
***************
*** 928,933 ****
--- 1040,1048 ----
      gint min_w, max_w, min_h, max_h, fix_num = 0, fix_denom = 0;
  
      /* This code is for Linux < 2.6.19 */
+     #if defined(DAVINCI_LSP_WORKAROUND)
+     gst_v4l2src_get_resolution(v4l2src, &min_w, &min_h, &fix_num, &fix_denom);      gst_v4l2src_get_resolution(v4l2src, &max_w, &max_h, &fix_num, &fix_denom); 
+     #else
      min_w = min_h = 1;
      max_w = max_h = GST_V4L2_MAX_SIZE;
      if (!gst_v4l2src_get_nearest_size (v4l2src, pixelformat, &min_w, &min_h)) {
***************
*** 940,945 ****
--- 1055,1061 ----
            "Could not probe maximum capture size for pixelformat %"
            GST_FOURCC_FORMAT, GST_FOURCC_ARGS (pixelformat));
      }
+     #endif
  
      /* Since we can't get framerate directly, try to use the current norm */
      if (v4l2src->v4l2object->norm && v4l2src->v4l2object->norms) {
***************
*** 954,961 ****
--- 1070,1079 ----
        }
        /* If it's possible, set framerate to that (discrete) value */
        if (norm) {
+         #if !defined(DAVINCI_LSP_WORKAROUND)
          fix_num = gst_value_get_fraction_numerator (&norm->framerate);
          fix_denom = gst_value_get_fraction_denominator (&norm->framerate);
+         #endif
        }
      }
  
***************
*** 1104,1110 ****
--- 1222,1232 ----
    g_mutex_unlock (v4l2src->pool->lock);
  
    /* this can change at every frame, esp. with jpeg */
+   #if defined(DAVINCI_LSP_WORKAROUND)
+   GST_BUFFER_SIZE (pool_buffer) = v4l2src->frame_byte_size;
+   #else
    GST_BUFFER_SIZE (pool_buffer) = buffer.bytesused;
+   #endif
  
    if (G_UNLIKELY (need_copy)) {
      *buf = gst_buffer_copy (pool_buffer);
***************
*** 1219,1225 ****
--- 1341,1352 ----
    /* request whole frames; change when gstreamer supports interlaced video
     * (INTERLACED mode returns frames where the fields have already been
     *  combined, there are other modes for requesting fields individually) */
+   #if defined(DAVINCI_LSP_WORKAROUND) && !defined(Platform_dm6467)
    format.fmt.pix.field = V4L2_FIELD_INTERLACED;
+   #endif
+   #if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm6467) 
+   v4l2src->frame_byte_size = format.fmt.pix.sizeimage;
+   #endif
  
    if (v4l2_ioctl (fd, VIDIOC_S_FMT, &format) < 0) {
      if (errno != EINVAL)
***************
*** 1568,1573 ****
--- 1695,1707 ----
    /* get size delimiters */
    memset (&fmt, 0, sizeof (fmt));
    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+   #if defined(DAVINCI_LSP_WORKAROUND)
+   r = ioctl(fd, VIDIOC_G_FMT, &fmt);
+   if (r < 0) {
+     GST_ERROR("Failed to get format\n");
+     return FALSE;
+   } 
+   #endif
    fmt.fmt.pix.width = *width;
    fmt.fmt.pix.height = *height;
    fmt.fmt.pix.pixelformat = pixelformat;
